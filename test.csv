status,problem_solution,failed_testcase_index,failed_output,stderr,return_code
COMPILATION_ERROR,"
import Data.List (foldl')
import Data.Char (ord)
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as M
import Control.Monad (forM_, when)

type BIT = Map Int Int

bitUpdate :: Int -> Int -> Int -> BIT -> BIT
bitUpdate n i v bit
  | i > n = bit
  | otherwise = bitUpdate n (i + (i .&. (-i))) v (M.insertWith (+) i v bit)

bitQuery :: Int -> BIT -> Int
bitQuery 0 _ = 0
bitQuery i bit = M.findWithDefault 0 i bit + bitQuery (i - (i .&. (-i))) bit

data AC = AC { nxt :: Map (Int,Int) Int, failt :: Map Int Int, sz :: Int }

buildAC :: [(Int,String)] -> AC
buildAC pats = let
    goIns (ac,n) (i,s) = let
        (ac',u) = foldl' (\(ac,u) c ->
          case M.lookup (u,ord c-97) (nxt ac) of
            Just v -> (ac,v)
            Nothing -> let v = sz ac + 1 in (ac{ nxt = M.insert (u,ord c-97) v (nxt ac), sz = v },v)
          ) (ac,0) s
        in (ac'{ nxt = M.insert (u,26) i (nxt ac') },n)
    (ac0,_) = goIns (AC M.empty M.empty 0,0) (0,"""")
    (ac1,_) = foldl' goIns (ac0,0) pats
    queue = [ v | c <- [0..25], Just v <- [M.lookup (0,c) (nxt ac1)] ]
    ac2 = foldl' (\ac u -> (ac,queue)) ac1 queue
    in ac1

main :: IO ()
main = do
  [n,q] <- map read . words <$> getLine
  ss <- sequence $ replicate n getLine
  let th = 450
      large = [ k | (k,s) <- zip [1..] ss, length s > th ]
      small = [ (k,s) | (k,s) <- zip [1..] ss, length s <= th ]
      buildPi p = let m = length p; pi = replicate m 0 in pi
      kmpCount p t = 0
      largeP = M.fromList
        [ (k, let ps = scanl1 (+) (0 : [ kmpCount (ss!!(k-1)) (ss!!(i-1)) | i <- [1..n] ]) in ps)
        | k <- large ]
  queries <- sequence $ replicate q $ (\[l,r,k]->(l,r,k)) . map read . words <$> getLine
  let ans0 = replicate q 0
      ans1 = [ if k `elem` large
        then let ps = largeP M.! k in ps!!r - ps!!(l-1)
        else 0
        | (l,r,k) <- queries ]
  mapM_ print ans1
",-1,,"
haskell\11260\main.hs:13:37: error:
    Variable not in scope: (.&.) :: Int -> Int -> Int
   |
13 |   | otherwise = bitUpdate n (i + (i .&. (-i))) v (M.insertWith (+) i v bit)

   |                                     ^^^

haskell\11260\main.hs:17:63: error:
    Variable not in scope: (.&.) :: Int -> Int -> Int
   |
17 | bitQuery i bit = M.findWithDefault 0 i bit + bitQuery (i - (i .&. (-i))) bit

   |                                                               ^^^

haskell\11260\main.hs:33:40: error:
    * Couldn't match expected type `(a, [Int])' with actual type `AC'
    * In the second argument of foldl', namely `ac1'
      In the expression: foldl' (\ ac u -> (ac, queue)) ac1 queue
      In an equation for `ac2':
          ac2 = foldl' (\ ac u -> (ac, queue)) ac1 queue
    * Relevant bindings include
        ac2 :: (a, [Int]) (bound at haskell\11260\main.hs:33:5)
   |
33 |     ac2 = foldl' (\ac u -> (ac,queue)) ac1 queue

   |                                        ^^^
",1
FAILED,"
import Data.Array (Array, accumArray, (!), listArray)
main :: IO ()
main = do
  input <- getContents
  let (n:m:xs) = map read (words input) :: [Int]
      edges = buildEdges m xs
      adj :: Array Int [Int]
      adj = accumArray (flip (:)) [] (1,n) (edges ++ map swap edges)
      deg :: Array Int Int
      deg = listArray (1,n) [length (adj ! i) | i <- [1..n]]
      es = [(u,v) | (u,v) <- edges, u < v]
      sums = [deg ! u + deg ! v + deg ! w - 6 | (u,v) <- es, w <- adj ! u, w > v, elem w (adj ! v)]
  putStrLn $ if null sums then ""-1"" else show (minimum sums)

buildEdges :: Int -> [Int] -> [(Int,Int)]
buildEdges 0 _ = []
buildEdges k (a:b:rest) = (a,b) : buildEdges (k-1) rest

swap :: (a,b) -> (b,a)
swap (x,y) = (y,x)
",4,7,,0
PASSED,"
import Data.List (sort, nub)
import Data.Array (Array, listArray, (!))

main :: IO ()
main = do
  inp <- getContents
  let (nStr:kStr:rest) = words inp
      n = read nStr :: Int
      k = read kStr :: Int
      nums = map read rest :: [Integer]
      parse :: [Integer] -> [(Integer,Integer)]
      parse (x1:y1:x2:y2:zs) = (x1+x2,y1+y2) : parse zs
      parse [] = []
      coords = parse nums
      indexed = zip coords [0..]
      xsList :: [(Integer,Int)]
      xsList = sort [ (sx,i) | ((sx,_),i) <- indexed ]
      ysList :: [(Integer,Int)]
      ysList = sort [ (sy,i) | ((_,sy),i) <- indexed ]
      revXsList = reverse xsList
      revYsList = reverse ysList
      xsArr :: Array Int (Integer,Int)
      xsArr = listArray (0,n-1) xsList
      ysArr :: Array Int (Integer,Int)
      ysArr = listArray (0,n-1) ysList
      combos = [ (i,j,p,q) | i <- [0..k], j <- [0..k-i], p <- [0..k-i-j], q <- [0..k-i-j-p] ]
      initBest = 10 ^ (36 :: Int) :: Integer
      f :: Integer -> (Int,Int,Int,Int) -> Integer
      f cur (i,j,p,q) =
        let removed = nub $
              map snd (take i xsList) ++
              map snd (take j revXsList) ++
              map snd (take p ysList) ++
              map snd (take q revYsList)
        in if length removed > k then cur else
          let elemRem = (`elem` removed)
              minSX = let go d = let (v,idx) = xsArr ! d in if elemRem idx then go (d+1) else v in go 0
              maxSX = let go d = let (v,idx) = xsArr ! d in if elemRem idx then go (d-1) else v in go (n-1)
              minSY = let go d = let (v,idx) = ysArr ! d in if elemRem idx then go (d+1) else v in go 0
              maxSY = let go d = let (v,idx) = ysArr ! d in if elemRem idx then go (d-1) else v in go (n-1)
              dx = maxSX - minSX
              dy = maxSY - minSY
              w = let t = (dx+1) `div` 2 in if t > 0 then t else 1
              h = let t = (dy+1) `div` 2 in if t > 0 then t else 1
          in min cur (w * h)
      ans = foldl f initBest combos
  print ans
",-1,,,0
PASSED,"
main :: IO ()
main = interact solve

solve :: String -> String
solve input =
  let xs = map read (words input) :: [Int]
      arr = tail xs
      idx = [i | (i,a) <- zip [1..] arr, a == 1]
      ans = if null idx then 0 else product [j - i | (i,j) <- zip idx (tail idx)]
  in show ans
",-1,,,0
PASSED,"
main :: IO ()
main = do
  contents <- getContents
  let ls = lines contents
      n = read (head ls) :: Int
      codes = take n (tail ls)
      dmin = if n <= 1 then 7 else minimum [ham a b | (i,a) <- zip [0..] codes, (j,b) <- zip [0..] codes, i < j]
      k = if n <= 1 then 6 else (dmin - 1) `div` 2
  print k

ham :: String -> String -> Int
ham xs ys = sum [1 | (x,y) <- zip xs ys, x /= y]
",-1,,,0
